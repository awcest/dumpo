# Structured Exception Handling (SEH) Introduction

SEH is a mechanism in Windows that allows programs to handle exceptions (errors) *gracefully*.

*Gracefully* means that the program can catch errors and take appropriate actions instead of crashing unexpectedly.

The CPU saves the system state when an exception happens, then transfers control to the kernel, which then calls the exception handler.

## Role of the Kernel

- The kernel determines where to send the exception:
    - Could be handled by the kernel itself (this happens for critical exceptions).
    - By a debugger (if one is attached).
    - Or passed to *user-mode exception handlers* (UEH) (which are part of the application).

## Userland exception handling

- Focuses on **user-registered exception handlers** (like those set with `TRY-EXCEPT` blocks).
- Explains how programs register handlers at runtime, defining how exceptions are handled.

## Thread Information Block (TIB)

- Each thread has a **Thread Information Block (TIB)**, that contains exception registration information.
- The exception handler list inside the TIB is thread specific and important for locating the right handler for an exception.

## How handlers work

- Exception registration records contain:
    - A pointer to the next handler in the list.
    - A callback function to handle the exception.

Devs can even manually manipulate these if doing low-level assembly or OS level programming, though compilers (like Visual Studio) manage this automatically.

## Passing exceptions

- When an excpetion happens, the kernel passes full context information (registers, stack, etc) to the user-mode exception handler.
- This includes data structures like `EXCEPTION_RECORD` and `CONTEXT`, which provide details about the exception and the state of the thread at the time of the exception.

## Exception Records

Contains:
- Exception code (like `EXCEPTION_ACCESS_VIOLATION`). ~ the reason for the exception.
- Faulting memory address (where the exception occurred).
- Additional exception parameters (if any).

## SEH filter functions

- SEH filter functions are used to determine how to handle exceptions.
- Filters are like decision points that decide whether to continue execution, terminate the program, or take some other action.
- The SEH mechanism will invoke the correct filter function during an exception.
- Developers don't register these filters manually when using normal `try except` blocks.

## Return flags

- When an exception occurs, the SEH mechanism uses return flags to determine how to proceed:

```md
    - `EXCEPTION_CONTINUE_SEARCH`: Continue searching for
    a handler.
    - `EXCEPTION_CONTINUE_EXECUTION`: Continue execution
    at the point of the exception (not recommended).
    - `EXCEPTION_EXECUTE_HANDLER`: Execute the handler
    and then continue execution.
```

## Try-Except Blocks

- At the assembly binary level, `try-except` blocks are implemented using a combination of instructions that set up the exception handling environment.
- **Scope tables** are used to define the boundaries of the `try` block. They are created by the compiler and contain information about the exception handlers associated with the `try` block.
- **Scope records** are used to manage the lifetime of the exception handler, ensuring that it is cleaned up when the `try` block exits.
    - Each scope record contains:
            - Enclosing label (for *nested* `try` blocks).
            - Filter function (if any).
            - Handler function (the function to execute when an exception occurs).

## Scope table records

- Scope table record fields:
    - `GS Cookie Offset` and `GS Cookie XOR Offset`: Used to detect stack corruption.
    - `ES Cookie Offset` and `ES Cookie XOR Offset`: Used to detect stack corruption in functions with EH.

## Stack setup for Exception Registration

Exception registration records are created on the stack when a `try` block is entered. The stack frame for the `try` block contains:
- A pointer to the previous exception registration record.
- A pointer to the exception handler function.
- A pointer to the filter function (if any).

`FS:[0]` (x86) or `GS:[0]` (x64) is used to access the TIB, which contains the exception registration information for the current thread.

XOR operations are used to protect against stack corruption by ensuring that the stack frame is valid and has not been tampered with. It can be thought of as a checksum for the stack frame, or an encryption mechanism to prevent tampering.

In summary, some addresses get encoded using XOR operations to protect against tampering. This is done by XORing the address with a specific value (like `0xDEADBEEF`), which makes it harder for attackers to predict or manipulate the address.

## Setting the Try Level and entering the Try Block

The ode sets the try level (TL) value:
- Negative when outside a try block
- Set to 0, 1, 2, etc, when inside specific try blocks

For example, the function enters a try block, runs a null buffer to cause a crash, and eventually jumps to the exception handler.

## Exception filters and handlers

- filter functions are used to determine how to handle exceptions.
- handler functions are used to execute the code that handles the exception.

Microsoft compiler generates these functions automatically when using `try-except` blocks.

> [!NOTE]
> One can use IDA disassembler to view the generated code and see how the exception handling is implemented (even if no high-level try-catch is shown).

