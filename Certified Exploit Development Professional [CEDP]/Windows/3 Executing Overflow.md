# Executing Overflow

The instructor use a vulnerable program (I won't spoil the name here, but you can find it in the course materials). Despite the topic being different from the previous module (Linux), the concepts are similar and the execution flow is the same.

The tool used is x32dbg with Mona module (a module for Immunity Debugger that provides additional functionality for exploit development, it can work with x32dbg as well, but with limitations). The vulnerability is a stack overflow.

The program lacks DEP (Data Execution Prevention) in the first phase of testing, making the stack executable.

**The flow is already known**:

- There's a field in the program that allows the user to input an IP, but it doesn't validate the input length.
- We prepare a payload that overflow the buffer to check if we can control the EIP (Extended Instruction Pointer).
- In this case, the crash happens after overwriting EAX register (that holds the next instruction to execute) with part of the buffer.
- The disassembly shows the crash is due to an invalid memory reference caused by the overwritten register.
- We do a stack analysis then, the inspection shows the buffer overwrote **Structured Exception Handler (SEH)** related areas.
- The exception handler gets overwritten with attacker-controlled data (`41414141` = "AAAA").
- The EIP got overwritten, but we don't know the exact offset that overwrote it.
- The debugger gets a first chance to handle the crash before Windows does.

To identify the exact offset, we can use Mona to generate a pattern (the same way as previously done in the Linux module with other tools).
            
## Understanding the SEH structure
- **SEH Layout**:
    - **First 4 bytes**: Next SEH pointer (nSEH) ~ points to the next exception handler.
    - **Next 4 bytes**: SEH handler address (SEH) ~ contains the address of the exception handler.
        - If an attacker controls the SEH, they can redirect execution flow to their payload.

## Crafting the Next Exploit Payload

- Sent 1312 `"A"` characters followed by custom values (`"BBBB"` and `"CCCC"`) for **nSEH** and **SEH**, respectively.
    
- Re-ran the crash and successfully controlled both **nSEH** and **SEH**.

- After triggering the SEH, the program executes the overwritten SEH, causing **EIP** to load the controlled value (`"CCCC"`/hex equivalent).
    
- Confirmed then: EIP is now under the attacker's control.

The problem here is that The ESP is pointing far away from the user-controlled buffer in the stack. To execute shellcode or build further exploit chains, we need to pivot the stack to the buffer region.

## Introduction to Stack Pivoting:

Stack Pivoting is a technique to adjust ESP to point to a different memory area (the attacker's buffer). We can use ROP gadgets to achieve this. The challenge with Available Modules (DLL Protections) is that not all modules can be used to find gadgets because of security protections like:
    - DEP / NX (Non-executable stack)
    - ASLR (Address Space Layout Randomization)
    - SafeSEH

We then locate a suitable DLL that has minimal protections and is a good candidate for finding gadgets.

This is done by running !mona modules to list modules and check protections. Careful attention is given to avoiding gadgets from modules with ASLR/SafeSEH enabled.

## POP POP RET

Other way to pivot the stack is using a **POP POP RET** gadget. This gadget pops two values from the stack and returns to the next instruction, effectively allowing us to control the stack pointer (ESP) and redirect execution flow. It's as simple as that.
