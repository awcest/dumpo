## Stack Based Overflow: Windows
### Introduction to Windows process architecture

#### Process analogy

- **Process**: A process is an instance of a program in execution, containing its own memory space, code, data, and system resources. It works as *houses* ðŸ .
- **Thread**: A thread functions as small tasks within a process (a lightweight unit of execution), enabling multiple operations to run concurrently and allowing the program to work efficiently. Threads share the same memory space of the process, which allows them to communicate easily. Can ben thought of as *people living and working* inside the house ðŸ‘¥.
- **Stack (stage)**: The stack is a region of memory used for storing temporary data, such as function parameters, return addresses and such. It operates in a Last In First Out (LIFO) configuration. It can be visualized as the *thread's private workspace* ðŸ”’.
- **Registers**: Registers are small, ~high-speed storage locations within the CPU that hold data and instruction pointers temporarily during processing. They are used for quick access to frequently used values and instructions. It's like the *personal belongings of each person* (threads) in the house ðŸ§³.

> [!IMPORTANT] 
> Threads operate within their own stack and register set, but shares the process's heap, static data, and OS resources.

Ok, but what are *heaps*?

```md
- **Heaps** are regions of a process's memory used for
dynamic memory allocation. While the stack is managed
*automatically*, the heap is managed *manually* by the
dev (using functions like *malloc* in C, for example).
Basically, The heap allows a process to allocate and 
free memory at runtime. More than one threads in a
process can share access to the heap.
```

#### Process memory layout (32bit vs 64bit)

- **32bit systems**:
  - Each process usually has 4GB virtual address space, split into 2GB for *userland* and 2GB for *Kernel space*.
- **64bit systems**:
  - Larger memory space.
  - As an example, Windows 10 uses 48bit addressing (despite being on a 64bit system), giving each process access to up to 128TB.
  - Total addressable space: 256TB ~ 128TB for userland, 128 for Kernel.

```md
.
â””â”€â”€ 2^48 (because we're talking about a binary system :) )
Â Â   â””â”€â”€ 281.474.976.710.656 bytes
        â””â”€â”€ 256 TB
            â””â”€â”€ 256 / 2
                â””â”€â”€ 128TB for *userland*, 128TB for *kernel*
```

> [!IMPORTANT]
> Windows internals treat many OS resources as objects, such as files, threads, processes, registry keys and events. Tools like WinObj help visualize the current active objects.

### Memory regions in a process

#### Image Sections (Executable Mappings)

- Memory areas where executable binaries and DLLs are loaded

#### Private Mappings (Private Regions)

- Memory areas exclusive to a single process, not shared with others.
- Used for temporary data, private heaps, thread stacks and dynammically allocated data.

#### Mapped Files (Memory-Mapped Files)

- Regions where disk are directly loaded into memory via file mapping.
- **Example:** when a process uses APIs like *MapViewOfFile*.
- Efficiently sharing large files between processes and accelerating disk read/write operations.

##### How threads use these regions?

- All threads in a process access global regions, unless explicitly isolated:

```md
.
â”œâ”€â”€ Image
â”œâ”€â”€ Heap
â””â”€â”€ Etc...
```

- private thread regions (like the stack and certain registers) are exclusive to that thread

*"Each thread has its own stack and private registers."*

##### Visual summary of memory regions in a process:

|Region Type|Description|Example|
|---|---|---|
|**Image Section**|Executable code and DLLs|Notepad.exe, kernel32.dll, etc.|
|**Private Memory**|Process-exclusive data|Heaps, Stacks, internal buffers|
|**Mapped File**|Files loaded via mapping APIs|Configuration files in RAM|
